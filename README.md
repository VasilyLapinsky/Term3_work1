# Term3_work1
Целью задачи являлось, реализовать компилятор языка работы над массивами, которому на вход поступал файл с операциями над массивами формата”.txt”, выходные данные выводились в консоль. 
Язык операций над массивами задавался следующими правилами:
1. буква   - любая буква латинского алфавита
2. цифра  - любая десятичная цифра
3. иден  -  идентификатор длины не более m (m = 2, 3 или  4)
4. число  - строка из пяти цифр, перед которой стоит знак «плюс» или «минус» (рассматриваются только целые числа)
5. символ  - символ, допускаемый в записи программы на языке
6. языковая программа - последовательность операторов языка, разделенных точкой с запятой (;) и не имеющих пробелов; первый, встречающийся пробел, в записи программы, трактуется как ее конец.
 символ  : :=  буква  |  цифра  |  знак  |  разделитель  
 знак  : :=  + | − | * | / 
 разделитель  : :=  ; | : |  = | (|) |   | , 
 массив : :=   иден  | ( число , . . . ,  число  ) 
Примечание. Количество r чисел в массиве фиксируется в языке (m = 3, 4 или 5).
 оператор : :=  иден  :=  массив  |  иден  :=  массив +  знак  + массив  
Выполнение операторов: идентификатор обозначает массив из  m чисел. Оператор вида  
иден := ( число , . . . ,  число )
выполняется путем присваивания  i-му элементу массива  i-го числа. Например, X := (3, 8, -19) означает серию операторов присваивания X [1] := 3, X[2] := 8, X[3] := -19.  Выполнение оператора вида
	 иден  :=  иден     
сводится к копированию массива. 
Например, A1 := Б означает A1[1] := Б[1]; A1[2] := Б[2]; A1[3] := Б[3].
Выполнение оператора, правая часть которого содержит операцию над двумя массивами, сводится к поэлементной операции между соответствующими  элементами двух  массивов.  Например, X = A / Б    означает X[1] := A[1]/ Б[1],  X[2] := A[2] / Б[2],  X[3] := A[3] / Б[3] (при m = 3). 
Пример программы:
X := (+00001,  -00010,  -00156);  A := X * (+00005, -12079, +44172);  X := A - X; 
Так же компилятор должен осуществлять проверку на соответствие следующим условиям:
1) использование в программе только допустимых символов;
2) длина идентификатора не превышает заданного числа m;
3) число содержит ровно пять цифр;
4) после точки с запятой может быть либо буква, либо пробел;
5) после “ : “ может быть только знак “ = “;
6) количество открывающих скобок должно совпадать с количеством закрывающих скобок;
7) если идентификатор входит в правую часть некоторого оператора, то он должен входить и в левую часть какого-нибудь предшествующего оператора.
8) внутри круглых скобок ровно  r 1 запятая;
9) внутри круглых скобок могут быть только цифры, запятая и знаки «плюс» и «минус». 
Если поданные на вход операции над массивами не соответствуют  вышесказанным правилам, то компилятор прерывает работу и выводить в консоль текст с соответствующей ошибкой.
В результате выполнения работы, должен получиться компилятор формальных операций над массивами, который, в свою очередь, должен выполнять проверку синтаксиса полученных операций и в случае правильности выполнять эти действия.
В начале программы я определяю глобальные переменные, такие как: размер массива, длина идентификатора, массив используемых символов и контейнер типа map<string, vector<int>>, который будет хранить созданные в ходе работы программы переменные.
Далее в программе я определяю следующие функции:
•	bool check_symbol(char temp), которая принимает символ и проверяет является ли он допустимым
•	int make_number(istream& in), данная функция принимает на вход поток и формирует число, и возвращает его в качестве результата
•	vector<int> make_mas(istream& in) формирует массив чисел и возвращает его в качестве результата
•	string make_indenfecator(istream& in) формирует идентификатор из переданного потока
•	vector<int> do_oper(vector<int> a, vector<int> b, char oper) выполняет операцию над двумя массивами и возвращает новый массив в качестве результата
•	void do_program(istream& in) выполняет оператор 
•	int main() осуществляет основную работу программы
Все выше перечисленные функции используют стандартные возможности обработки ошибок языка C++ в случае возникновения их в ходе работы программы. 
	Программа на вход принимает текстовый файл и в случае правильности поданной программы в консоль выводятся все конечные значения всех созданных переменных в ходе работы программы, если входной файл содержит ошибку то программа прервет свою работу и выведет соответствующий текст в консоль.
